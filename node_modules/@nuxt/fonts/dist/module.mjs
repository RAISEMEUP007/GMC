import { useLogger, useNuxt, addDevServerHandler, createResolver, defineNuxtModule, addTemplate, addBuildPlugin, resolvePath, resolveAlias } from '@nuxt/kit';
import jiti from 'jiti';
import { join, relative, resolve, extname } from 'pathe';
import { withTrailingSlash, withLeadingSlash, hasProtocol, joinURL, withQuery, joinRelativeURL, withoutLeadingSlash } from 'ufo';
import { globby } from 'globby';
import { filename } from 'pathe/utils';
import { createRegExp, anyOf, not, wordBoundary } from 'magic-regexp';
import { hash } from 'ohash';
import { findAll, parse, walk } from 'css-tree';
import { getMetricsForFamily, readMetrics, generateFontFace as generateFontFace$1 } from 'fontaine';
import { createStorage } from 'unstorage';
import fsDriver from 'unstorage/drivers/fs';
import defu, { defu as defu$1 } from 'defu';
import { fetch } from 'node-fetch-native/proxy';
import { createUnplugin } from 'unplugin';
import MagicString from 'magic-string';
import { transform } from 'esbuild';
import fsp from 'node:fs/promises';
import { lazyEventHandler, eventHandler, createError } from 'h3';
import chalk from 'chalk';
import { existsSync } from 'node:fs';
import { onDevToolsInitialized, extendServerRpc, addCustomTab } from '@nuxt/devtools-kit';

const providerContext = {
  rootPaths: [],
  registry: {}
};
const local = {
  async setup(_options, nuxt) {
    for (const layer of nuxt.options._layers) {
      const publicDir = join(layer.config.srcDir || layer.cwd, layer.config.dir?.public || "public");
      const possibleFontFiles = await globby("**/*.{ttf,woff,woff2,eot,otf}", {
        absolute: true,
        cwd: publicDir
      });
      providerContext.rootPaths.push(withTrailingSlash(publicDir));
      for (const file of possibleFontFiles) {
        registerFont(file);
      }
    }
    providerContext.rootPaths = providerContext.rootPaths.sort((a, b) => b.length - a.length);
    nuxt.hook("builder:watch", (event, relativePath) => {
      relativePath = relative(nuxt.options.srcDir, resolve(nuxt.options.srcDir, relativePath));
      const path = resolve(nuxt.options.srcDir, relativePath);
      if (event === "add" && isFontFile(path)) {
        registerFont(path);
      }
      if (event === "unlink" && isFontFile(path)) {
        unregisterFont(path);
      }
    });
  },
  resolveFontFaces(fontFamily, defaults) {
    const fonts = [];
    for (const weight of defaults.weights) {
      for (const style of defaults.styles) {
        for (const subset of defaults.subsets) {
          const resolved = lookupFont(fontFamily, [weightMap$1[weight] || weight, style, subset]);
          if (resolved.length > 0) {
            fonts.push({
              src: resolved,
              weight,
              style
            });
          }
        }
      }
    }
    if (fonts.length > 0) {
      return {
        fonts
      };
    }
  }
};
const FONT_RE = /\.(ttf|woff|woff2|eot|otf)(\?[^.]+)?$/;
const NON_WORD_RE = /[^\w\d]+/g;
const isFontFile = (id) => FONT_RE.test(id);
const weightMap$1 = {
  100: "thin",
  200: "extra-light",
  300: "light",
  400: "normal",
  500: "medium",
  600: "semi-bold",
  700: "bold",
  800: "extra-bold",
  900: "black"
};
const weights = Object.entries(weightMap$1).flatMap((e) => e).filter((r) => r !== "normal");
const WEIGHT_RE = createRegExp(anyOf(...weights).groupedAs("weight").after(not.digit).before(not.digit.or(wordBoundary)), ["i"]);
const styles = ["italic", "oblique"];
const STYLE_RE = createRegExp(anyOf(...styles).groupedAs("style").before(not.wordChar.or(wordBoundary)), ["i"]);
const subsets = [
  "cyrillic-ext",
  "cyrillic",
  "greek-ext",
  "greek",
  "vietnamese",
  "latin-ext",
  "latin"
];
const SUBSET_RE = createRegExp(anyOf(...subsets).groupedAs("subset").before(not.wordChar.or(wordBoundary)), ["i"]);
function generateSlugs(path) {
  let name = filename(path);
  const weight = name.match(WEIGHT_RE)?.groups?.weight || "normal";
  const style = name.match(STYLE_RE)?.groups?.style || "normal";
  const subset = name.match(SUBSET_RE)?.groups?.subset || "latin";
  for (const slug of [weight, style, subset]) {
    name = name.replace(slug, "");
  }
  const slugs = /* @__PURE__ */ new Set();
  for (const slug of [name.replace(/[.][\w\d]*$/, ""), name.replace(/[._-][\w\d]*$/, "")]) {
    slugs.add([
      fontFamilyToSlug(slug.replace(/[\W._-]+$/, "")),
      weightMap$1[weight] || weight,
      style,
      subset
    ].join("-").toLowerCase());
  }
  return [...slugs];
}
function registerFont(path) {
  const slugs = generateSlugs(path);
  for (const slug of slugs) {
    providerContext.registry[slug] ||= [];
    providerContext.registry[slug].push(path);
  }
}
function unregisterFont(path) {
  const slugs = generateSlugs(path);
  for (const slug of slugs) {
    providerContext.registry[slug] ||= [];
    providerContext.registry[slug] = providerContext.registry[slug].filter((p) => p !== path);
  }
}
const extensionPriority = ["woff2", "woff", "ttf", "otf", "eot"];
function lookupFont(family, suffixes) {
  const slug = [fontFamilyToSlug(family), ...suffixes].join("-");
  const paths = providerContext.registry[slug];
  if (!paths || paths.length === 0) {
    return [];
  }
  const fonts = /* @__PURE__ */ new Set();
  for (const path of paths) {
    const base = providerContext.rootPaths.find((root) => path.startsWith(root));
    fonts.add(base ? withLeadingSlash(relative(base, path)) : path);
  }
  return [...fonts].sort((a, b) => {
    const extA = filename(a).split(".").pop();
    const extB = filename(b).split(".").pop();
    return extensionPriority.indexOf(extA) - extensionPriority.indexOf(extB);
  });
}
function fontFamilyToSlug(family) {
  return family.toLowerCase().replace(NON_WORD_RE, "");
}

function generateFontFace(family, font) {
  return [
    "@font-face {",
    `  font-family: '${family}';`,
    `  src: ${renderFontSrc(font.src)};`,
    `  font-display: ${font.display || "swap"};`,
    font.unicodeRange && `  unicode-range: ${font.unicodeRange};`,
    font.weight && `  font-weight: ${Array.isArray(font.weight) ? font.weight.join(" ") : font.weight};`,
    font.style && `  font-style: ${font.style};`,
    font.stretch && `  font-stretch: ${font.stretch};`,
    font.featureSettings && `  font-feature-settings: ${font.featureSettings};`,
    font.variationSettings && `  font-variation-settings: ${font.variationSettings};`,
    `}`
  ].filter(Boolean).join("\n");
}
async function generateFontFallbacks(family, data, fallbacks) {
  if (!fallbacks?.length)
    return [];
  const fontURL = data.src.find((s) => "url" in s);
  const metrics = await getMetricsForFamily(family) || fontURL && await readMetrics(fontURL.originalURL || fontURL.url);
  if (!metrics)
    return [];
  const css = [];
  for (const fallback of fallbacks) {
    css.push(generateFontFace$1(metrics, {
      ...fallback,
      metrics: await getMetricsForFamily(fallback.font) || void 0
    }));
  }
  return css;
}
const formatMap = {
  woff2: "woff2",
  woff: "woff",
  otf: "opentype",
  ttf: "truetype",
  eot: "embedded-opentype",
  svg: "svg"
};
const formatPriorityList = Object.values(formatMap);
const extensionMap = Object.fromEntries(Object.entries(formatMap).map(([key, value]) => [value, key]));
const formatToExtension = (format) => format && format in extensionMap ? "." + extensionMap[format] : void 0;
function parseFont(font) {
  if (font.startsWith("/") || hasProtocol(font)) {
    const extension = extname(font).slice(1);
    const format = formatMap[extension];
    return {
      url: font,
      format
    };
  }
  return { name: font };
}
function renderFontSrc(sources) {
  return sources.map((src) => {
    if ("url" in src) {
      let rendered = `url("${src.url}")`;
      for (const key of ["format", "tech"]) {
        if (key in src) {
          rendered += ` ${key}(${src[key]})`;
        }
      }
      return rendered;
    }
    return `local("${src.name}")`;
  }).join(", ");
}

const extractableKeyMap = {
  "src": "src",
  "font-display": "display",
  "font-weight": "weight",
  "font-style": "style",
  "font-feature-settings": "featureSettings",
  "font-variations-settings": "variationSettings",
  "unicode-range": "unicodeRange"
};
const weightMap = {
  100: "Thin",
  200: "ExtraLight",
  300: "Light",
  400: "Regular",
  500: "Medium",
  600: "SemiBold",
  700: "Bold",
  800: "ExtraBold",
  900: "Black"
};
const styleMap$1 = {
  italic: "Italic",
  oblique: "Oblique",
  normal: ""
};
function extractFontFaceData(css, family) {
  const fontFaces = [];
  for (const node of findAll(parse(css), (node2) => node2.type === "Atrule" && node2.name === "font-face")) {
    if (node.type !== "Atrule" || node.name !== "font-face") {
      continue;
    }
    if (family) {
      const isCorrectFontFace = node.block?.children.some((child) => {
        if (child.type !== "Declaration" || child.property !== "font-family") {
          return false;
        }
        const value = extractCSSValue(child);
        const slug = family.toLowerCase();
        if (typeof value === "string" && value.toLowerCase() === slug) {
          return true;
        }
        if (Array.isArray(value) && value.length > 0 && value.some((v) => v.toLowerCase() === slug)) {
          return true;
        }
        return false;
      });
      if (!isCorrectFontFace) {
        continue;
      }
    }
    const data = {};
    for (const child of node.block?.children || []) {
      if (child.type === "Declaration" && child.property in extractableKeyMap) {
        const value = extractCSSValue(child);
        data[extractableKeyMap[child.property]] = child.property === "src" && !Array.isArray(value) ? [value] : value;
      }
    }
    fontFaces.push(data);
  }
  return mergeFontSources(fontFaces);
}
function processRawValue(value) {
  return value.split(",").map((v) => v.trim().replace(/^(?<quote>['"])(.*)\k<quote>$/, "$2"));
}
function extractCSSValue(node) {
  if (node.value.type == "Raw") {
    return processRawValue(node.value.value);
  }
  const values = [];
  let buffer = "";
  for (const child of node.value.children) {
    if (child.type === "Function") {
      if (child.name === "local" && child.children.first?.type === "String") {
        values.push({ name: child.children.first.value });
      }
      if (child.name === "format" && child.children.first?.type === "String") {
        values.at(-1).format = child.children.first.value;
      }
      if (child.name === "tech" && child.children.first?.type === "String") {
        values.at(-1).tech = child.children.first.value;
      }
    }
    if (child.type === "Url") {
      values.push({ url: child.value });
    }
    if (child.type === "Identifier") {
      buffer = buffer ? `${buffer} ${child.name}` : child.name;
    }
    if (child.type === "String") {
      values.push(child.value);
    }
    if (child.type === "Operator" && child.value === "," && buffer) {
      values.push(buffer);
      buffer = "";
    }
    if (child.type === "UnicodeRange") {
      values.push(child.value);
    }
    if (child.type === "Number") {
      values.push(Number(child.value));
    }
  }
  if (buffer) {
    values.push(buffer);
  }
  if (values.length === 1) {
    return values[0];
  }
  return values;
}
const _genericCSSFamilies = [
  "serif",
  "sans-serif",
  "monospace",
  "cursive",
  "fantasy",
  "system-ui",
  "ui-serif",
  "ui-sans-serif",
  "ui-monospace",
  "ui-rounded",
  "emoji",
  "math",
  "fangsong"
];
const genericCSSFamilies = new Set(_genericCSSFamilies);
const globalCSSValues = /* @__PURE__ */ new Set([
  "inherit",
  "initial",
  "revert",
  "revert-layer",
  "unset"
]);
function extractGeneric(node) {
  if (node.value.type == "Raw") {
    return;
  }
  for (const child of node.value.children) {
    if (child.type === "Identifier" && genericCSSFamilies.has(child.name)) {
      return child.name;
    }
  }
}
function extractEndOfFirstChild(node) {
  if (node.value.type == "Raw") {
    return;
  }
  for (const child of node.value.children) {
    if (child.type === "String") {
      return child.loc.end.offset;
    }
    if (child.type === "Operator" && child.value === ",") {
      return child.loc.start.offset;
    }
  }
  return node.value.children.last.loc.end.offset;
}
function extractFontFamilies(node) {
  if (node.value.type == "Raw") {
    return processRawValue(node.value.value);
  }
  const families = [];
  let buffer = "";
  for (const child of node.value.children) {
    if (child.type === "Identifier" && !genericCSSFamilies.has(child.name) && !globalCSSValues.has(child.name)) {
      buffer = buffer ? `${buffer} ${child.name}` : child.name;
    }
    if (buffer && child.type === "Operator" && child.value === ",") {
      families.push(buffer.replace(/\\/g, ""));
      buffer = "";
    }
    if (buffer && child.type === "Dimension") {
      buffer = (buffer + " " + child.value + child.unit).trim();
    }
    if (child.type === "String") {
      families.push(child.value);
    }
  }
  if (buffer) {
    families.push(buffer);
  }
  return families;
}
function mergeFontSources(data) {
  const mergedData = [];
  for (const face of data) {
    const keys = Object.keys(face).filter((k) => k !== "src");
    const existing = mergedData.find((f) => Object.keys(f).length === keys.length + 1 && keys.every((key) => f[key]?.toString() === face[key]?.toString()));
    if (existing) {
      existing.src.push(...face.src);
    } else {
      mergedData.push(face);
    }
  }
  for (const face of mergedData) {
    face.src.sort((a, b) => {
      const aIndex = "format" in a ? formatPriorityList.indexOf(a.format || "woff2") : -2;
      const bIndex = "format" in b ? formatPriorityList.indexOf(b.format || "woff2") : -2;
      return aIndex - bIndex;
    });
  }
  return mergedData;
}
function addLocalFallbacks(fontFamily, data) {
  for (const face of data) {
    const style = (face.style ? styleMap$1[face.style] : "") ?? "";
    if (Array.isArray(face.weight)) {
      face.src.unshift({ name: [fontFamily, "Variable", style].join(" ").trim() });
    } else if (face.src[0] && !("name" in face.src[0])) {
      const weights = (Array.isArray(face.weight) ? face.weight : [face.weight]).map((weight) => weightMap[weight]).filter(Boolean);
      for (const weight of weights) {
        if (weight === "Regular") {
          face.src.unshift({ name: [fontFamily, style].join(" ").trim() });
        }
        face.src.unshift({ name: [fontFamily, weight, style].join(" ").trim() });
      }
    }
  }
  return data;
}

const version = "0.7.0";

const cacheBase = "node_modules/.cache/nuxt/fonts/meta";
const storage = createStorage({
  driver: fsDriver({ base: cacheBase })
});
async function cachedData(key, fetcher, options) {
  const cached = await storage.getItem(key);
  if (!cached || cached.version !== version || cached.expires < Date.now()) {
    try {
      const data = await fetcher();
      await storage.setItem(key, { expires: Date.now() + (options?.ttl || 1e3 * 60 * 60 * 24 * 7), version, data });
      return data;
    } catch (err) {
      if (options?.onError) {
        return options.onError(err);
      }
      throw err;
    }
  }
  return cached.data;
}

const mini$fetch = (url, options) => {
  if (options?.baseURL) {
    url = joinURL(options.baseURL, url);
  }
  if (options?.query) {
    url = withQuery(url, options.query);
  }
  return fetch(url, options).then((r) => options?.responseType === "json" ? r.json() : options?.responseType === "arrayBuffer" ? r.arrayBuffer() : r.text());
};
const $fetch = Object.assign(mini$fetch, {
  create: (defaults) => (url, options) => mini$fetch(url, defu(options, defaults))
});

const logger = useLogger("@nuxt/fonts");

const google = {
  async setup() {
    await initialiseFontMeta$4();
  },
  async resolveFontFaces(fontFamily, defaults) {
    if (!isGoogleFont(fontFamily)) {
      return;
    }
    return {
      fonts: await cachedData(`google:${fontFamily}-${hash(defaults)}-data.json`, () => getFontDetails$4(fontFamily, defaults), {
        onError(err) {
          logger.error(`Could not fetch metadata for \`${fontFamily}\` from \`google\`.`, err);
          return [];
        }
      })
    };
  }
};
let fonts$4;
async function fetchFontMetadata() {
  return await $fetch("https://fonts.google.com/metadata/fonts", { responseType: "json" }).then((r) => r.familyMetadataList);
}
async function initialiseFontMeta$4() {
  fonts$4 = await cachedData("google:meta.json", fetchFontMetadata, {
    onError() {
      logger.error("Could not download `google` font metadata. `@nuxt/fonts` will not be able to inject `@font-face` rules for google.");
      return [];
    }
  });
}
function isGoogleFont(family) {
  return fonts$4.some((font) => font.family === family);
}
const styleMap = {
  italic: "1",
  oblique: "1",
  normal: "0"
};
async function getFontDetails$4(family, variants) {
  const font = fonts$4.find((font2) => font2.family === family);
  const styles = [...new Set(variants.styles.map((i) => styleMap[i]))].sort();
  const variableWeight = font.axes.find((a) => a.tag === "wght");
  const weights = variableWeight ? [`${variableWeight.min}..${variableWeight.max}`] : variants.weights.filter((weight) => weight in font.fonts);
  if (weights.length === 0 || styles.length === 0)
    return [];
  const resolvedVariants = weights.flatMap((w) => [...styles].map((s) => `${s},${w}`)).sort();
  let css = "";
  for (const extension in userAgents) {
    css += await $fetch("/css2", {
      baseURL: "https://fonts.googleapis.com",
      headers: { "user-agent": userAgents[extension] },
      query: {
        family: family + ":ital,wght@" + resolvedVariants.join(";")
      }
    });
  }
  return addLocalFallbacks(family, extractFontFaceData(css));
}
const userAgents = {
  woff2: "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36",
  ttf: "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/534.54.16 (KHTML, like Gecko) Version/5.1.4 Safari/534.54.16"
  // eot: 'Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident/4.0)',
  // woff: 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:27.0) Gecko/20100101 Firefox/27.0',
  // svg: 'Mozilla/4.0 (iPad; CPU OS 4_0_1 like Mac OS X) AppleWebKit/534.46 (KHTML, like Gecko) Version/4.1 Mobile/9A405 Safari/7534.48.3',
};

const bunny = {
  async setup() {
    await initialiseFontMeta$3();
  },
  async resolveFontFaces(fontFamily, defaults) {
    if (!isBunnyFont(fontFamily)) {
      return;
    }
    return {
      fonts: await cachedData(`bunny:${fontFamily}-${hash(defaults)}-data.json`, () => getFontDetails$3(fontFamily, defaults), {
        onError(err) {
          logger.error(`Could not fetch metadata for \`${fontFamily}\` from \`bunny\`.`, err);
          return [];
        }
      })
    };
  }
};
const fontAPI$3 = $fetch.create({
  baseURL: "https://fonts.bunny.net"
});
let fonts$3;
const familyMap$2 = /* @__PURE__ */ new Map();
async function initialiseFontMeta$3() {
  fonts$3 = await cachedData("bunny:meta.json", () => fontAPI$3("/list", { responseType: "json" }), {
    onError() {
      logger.error("Could not download `bunny` font metadata. `@nuxt/fonts` will not be able to inject `@font-face` rules for bunny.");
      return {};
    }
  });
  for (const id in fonts$3) {
    familyMap$2.set(fonts$3[id].familyName, id);
  }
}
function isBunnyFont(family) {
  return familyMap$2.has(family);
}
async function getFontDetails$3(family, variants) {
  const id = familyMap$2.get(family);
  const font = fonts$3[id];
  const weights = variants.weights.filter((weight) => font.weights.includes(Number(weight)));
  const styleMap = {
    italic: "i",
    oblique: "i",
    normal: ""
  };
  const styles = new Set(variants.styles.map((i) => styleMap[i]));
  if (weights.length === 0 || styles.size === 0)
    return [];
  const resolvedVariants = weights.flatMap((w) => [...styles].map((s) => `${w}${s}`));
  const css = await fontAPI$3("/css", {
    query: {
      family: id + ":" + resolvedVariants.join(",")
    }
  });
  return addLocalFallbacks(family, extractFontFaceData(css));
}

const fontshare = {
  async setup() {
    await initialiseFontMeta$2();
  },
  async resolveFontFaces(fontFamily, defaults) {
    if (!isFontshareFont(fontFamily)) {
      return;
    }
    return {
      fonts: await cachedData(`fontshare:${fontFamily}-${hash(defaults)}-data.json`, () => getFontDetails$2(fontFamily, defaults), {
        onError(err) {
          logger.error(`Could not fetch metadata for \`${fontFamily}\` from \`fontshare\`.`, err);
          return [];
        }
      })
    };
  }
};
const fontAPI$2 = $fetch.create({
  baseURL: "https://api.fontshare.com/v2"
});
let fonts$2;
const families = /* @__PURE__ */ new Set();
async function initialiseFontMeta$2() {
  fonts$2 = await cachedData("fontshare:meta.json", async () => {
    const fonts2 = [];
    let offset = 0;
    let chunk;
    do {
      chunk = await fontAPI$2("/fonts", {
        responseType: "json",
        query: {
          offset,
          limit: 100
        }
      });
      fonts2.push(...chunk.fonts);
      offset++;
    } while (chunk.has_more);
    return fonts2;
  }, {
    onError() {
      logger.error("Could not download `fontshare` font metadata. `@nuxt/fonts` will not be able to inject `@font-face` rules for fontshare.");
      return [];
    }
  });
  for (const font of fonts$2) {
    families.add(font.name);
  }
}
function isFontshareFont(family) {
  return families.has(family);
}
async function getFontDetails$2(family, variants) {
  const font = fonts$2.find((f) => f.name === family);
  const numbers = [];
  for (const style of font.styles) {
    if (style.is_italic && !variants.styles.includes("italic")) {
      continue;
    }
    if (!variants.weights.includes(String(style.weight.number))) {
      continue;
    }
    numbers.push(style.weight.number);
  }
  if (numbers.length === 0)
    return [];
  const css = await fontAPI$2(`/css?f[]=${font.slug + "@" + numbers.join(",")}`);
  return addLocalFallbacks(family, extractFontFaceData(css));
}

const adobe = {
  async setup(options) {
    if (!options.id) {
      return;
    }
    await initialiseFontMeta$1(typeof options.id === "string" ? [options.id] : options.id);
  },
  async resolveFontFaces(fontFamily, defaults) {
    if (!isAdobeFont(fontFamily)) {
      return;
    }
    return {
      fonts: await cachedData(`adobe:${fontFamily}-${hash(defaults)}-data.json`, () => getFontDetails$1(fontFamily, defaults), {
        onError(err) {
          logger.error(`Could not fetch metadata for \`${fontFamily}\` from \`adobe\`.`, err);
          return [];
        }
      })
    };
  }
};
const fontAPI$1 = $fetch.create({
  baseURL: "https://typekit.com"
});
const fontCSSAPI = $fetch.create({
  baseURL: "https://use.typekit.net"
});
let fonts$1;
const familyMap$1 = /* @__PURE__ */ new Map();
async function getAdobeFontMeta(id) {
  const { kit } = await fontAPI$1(`/api/v1/json/kits/${id}/published`, { responseType: "json" });
  return kit;
}
async function initialiseFontMeta$1(kits) {
  fonts$1 = {
    kits: await Promise.all(kits.map((id) => cachedData(`adobe:meta-${id}.json`, () => getAdobeFontMeta(id), {
      onError() {
        logger.error("Could not download `adobe` font metadata. `@nuxt/fonts` will not be able to inject `@font-face` rules for adobe.");
        return null;
      }
    }))).then((r) => r.filter((meta) => !!meta))
  };
  for (const kit in fonts$1.kits) {
    const families = fonts$1.kits[kit].families;
    for (const family in families) {
      familyMap$1.set(families[family].name, families[family].id);
    }
  }
}
function isAdobeFont(family) {
  return familyMap$1.has(family);
}
async function getFontDetails$1(family, variants) {
  variants.weights = variants.weights.map(String);
  for (const kit in fonts$1.kits) {
    const font = fonts$1.kits[kit].families.find((f) => f.name === family);
    if (!font) {
      continue;
    }
    const styles = [];
    for (const style of font.variations) {
      if (style.includes("i") && !variants.styles.includes("italic")) {
        continue;
      }
      if (!variants.weights.includes(String(style.slice(-1) + "00"))) {
        continue;
      }
      styles.push(style);
    }
    if (styles.length === 0) {
      continue;
    }
    const css = await fontCSSAPI(`${fonts$1.kits[kit].id}.css`);
    const slug = family.toLowerCase().split(" ").join("-");
    return addLocalFallbacks(family, extractFontFaceData(css, slug));
  }
  return [];
}

const fontsource = {
  async setup() {
    await initialiseFontMeta();
  },
  async resolveFontFaces(fontFamily, defaults) {
    if (!isFontsourceFont(fontFamily)) {
      return;
    }
    return {
      fonts: await cachedData(`fontsource:${fontFamily}-${hash(defaults)}-data.json`, () => getFontDetails(fontFamily, defaults), {
        onError(err) {
          logger.error(`Could not fetch metadata for \`${fontFamily}\` from \`fontsource\`.`, err);
          return [];
        }
      })
    };
  }
};
const fontAPI = $fetch.create({
  baseURL: "https://api.fontsource.org/v1"
});
let fonts;
const familyMap = /* @__PURE__ */ new Map();
async function initialiseFontMeta() {
  fonts = await cachedData("fontsource:meta.json", () => fontAPI("/fonts", { responseType: "json" }), {
    onError() {
      logger.error("Could not download `fontsource` font metadata. `@nuxt/fonts` will not be able to inject `@font-face` rules for fontsource.");
      return {};
    }
  });
  for (const id in fonts) {
    familyMap.set(fonts[id].family, id);
  }
}
function isFontsourceFont(family) {
  return familyMap.has(family);
}
async function getFontDetails(family, variants) {
  const id = familyMap.get(family);
  const font = fonts[id];
  const weights = variants.weights.filter((weight) => font.weights.includes(Number(weight)));
  const styles = variants.styles.filter((style) => font.styles.includes(style));
  const subsets = variants.subsets ? variants.subsets.filter((subset) => font.subsets.includes(subset)) : [font.defSubset];
  if (weights.length === 0 || styles.length === 0)
    return [];
  const fontDetail = await fontAPI(`/fonts/${font.id}`, { responseType: "json" });
  const fontFaceData = [];
  for (const subset of subsets) {
    for (const style of styles) {
      if (font.variable) {
        fontFaceData.push({
          style,
          weight: [font.weights[0], font.weights.slice(-1)[0]],
          src: [
            { url: `https://cdn.jsdelivr.net/fontsource/fonts/${font.id}:vf@latest/${subset}-wght-${style}.woff2`, format: "woff2" }
          ],
          unicodeRange: fontDetail.unicodeRange[subset]?.split(",")
        });
      }
      for (const weight of weights) {
        const variantUrl = fontDetail.variants[weight][style][subset].url;
        fontFaceData.push({
          style,
          weight,
          src: Object.entries(variantUrl).map(([format, url]) => ({ url, format })),
          unicodeRange: fontDetail.unicodeRange[subset]?.split(",")
        });
      }
    }
  }
  return addLocalFallbacks(family, fontFaceData);
}

const SKIP_RE = /\/node_modules\/(vite-plugin-vue-inspector)\//;
const FontFamilyInjectionPlugin = (options) => createUnplugin(() => {
  let postcssOptions;
  async function transformCSS(code, id) {
    const s = new MagicString(code);
    const injectedDeclarations = /* @__PURE__ */ new Set();
    const promises = [];
    async function addFontFaceDeclaration(fontFamily, fallbackOptions) {
      const result = await options.resolveFontFace(fontFamily, {
        generic: fallbackOptions?.generic,
        fallbacks: fallbackOptions?.fallbacks || []
      }) || {};
      if (!result.fonts || result.fonts.length === 0)
        return;
      const fallbackMap = result.fallbacks?.map((f) => ({ font: f, name: `${fontFamily} Fallback: ${f}` })) || [];
      let insertFontFamilies = false;
      if (result.fonts[0] && options.shouldPreload(fontFamily, result.fonts[0])) {
        const fontToPreload = result.fonts[0].src.find((s2) => "url" in s2)?.url;
        if (fontToPreload) {
          const urls = options.fontsToPreload.get(id) || /* @__PURE__ */ new Set();
          options.fontsToPreload.set(id, urls.add(fontToPreload));
        }
      }
      const prefaces = [];
      for (const font of result.fonts) {
        const fallbackDeclarations = await generateFontFallbacks(fontFamily, font, fallbackMap);
        const declarations = [generateFontFace(fontFamily, font), ...fallbackDeclarations];
        for (let declaration of declarations) {
          if (!injectedDeclarations.has(declaration)) {
            injectedDeclarations.add(declaration);
            if (!options.dev) {
              declaration = await transform(declaration, {
                loader: "css",
                charset: "utf8",
                minify: true,
                ...postcssOptions
              }).then((r) => r.code || declaration).catch(() => declaration);
            } else {
              declaration += "\n";
            }
            prefaces.push(declaration);
          }
        }
        if (fallbackDeclarations.length) {
          insertFontFamilies = true;
        }
      }
      s.prepend(prefaces.join(""));
      if (fallbackOptions && insertFontFamilies) {
        const insertedFamilies = fallbackMap.map((f) => `"${f.name}"`).join(", ");
        s.prependLeft(fallbackOptions.index, `, ${insertedFamilies}`);
      }
    }
    const ast = parse(code, { positions: true });
    const existingFontFamilies = /* @__PURE__ */ new Set();
    walk(ast, {
      visit: "Declaration",
      enter(node) {
        if (this.atrule?.name === "font-face" && node.property === "font-family") {
          for (const family of extractFontFamilies(node)) {
            existingFontFamilies.add(family);
          }
        }
      }
    });
    walk(ast, {
      visit: "Declaration",
      enter(node) {
        if (node.property !== "font-family" && (!options.processCSSVariables || !node.property.startsWith("--")) || this.atrule?.name === "font-face") {
          return;
        }
        const [fontFamily, ...fallbacks] = extractFontFamilies(node);
        if (fontFamily && !existingFontFamilies.has(fontFamily)) {
          promises.push(addFontFaceDeclaration(fontFamily, node.value.type !== "Raw" ? {
            fallbacks,
            generic: extractGeneric(node),
            index: extractEndOfFirstChild(node)
          } : void 0));
        }
      }
    });
    await Promise.all(promises);
    return s;
  }
  return {
    name: "nuxt:fonts:font-family-injection",
    transformInclude(id) {
      return isCSS(id) && !SKIP_RE.test(id);
    },
    async transform(code, id) {
      if (!options.processCSSVariables && !code.includes("font-family:")) {
        return;
      }
      const s = await transformCSS(code, id);
      if (s.hasChanged()) {
        return {
          code: s.toString(),
          map: s.generateMap({ hires: true })
        };
      }
    },
    vite: {
      configResolved(config) {
        if (options.dev || !config.esbuild || postcssOptions) {
          return;
        }
        postcssOptions = {
          target: config.esbuild.target,
          ...resolveMinifyCssEsbuildOptions(config.esbuild)
        };
      },
      renderChunk(code, chunk) {
        if (chunk.facadeModuleId) {
          for (const file of chunk.moduleIds) {
            if (options.fontsToPreload.has(file)) {
              options.fontsToPreload.set(chunk.facadeModuleId, options.fontsToPreload.get(file));
            }
          }
        }
      },
      async generateBundle(_outputOptions, bundle) {
        for (const key in bundle) {
          const chunk = bundle[key];
          if (chunk?.type === "asset" && isCSS(chunk.fileName)) {
            const s = await transformCSS(chunk.source.toString(), key);
            if (s.hasChanged()) {
              chunk.source = s.toString();
            }
          }
        }
      }
    }
  };
});
const IS_CSS_RE = /\.(?:css|scss|sass|postcss|pcss|less|stylus|styl)(\?[^.]+)?$/;
function isCSS(id) {
  return IS_CSS_RE.test(id);
}
function resolveMinifyCssEsbuildOptions(options) {
  const base = {
    charset: options.charset ?? "utf8",
    logLevel: options.logLevel,
    logLimit: options.logLimit,
    logOverride: options.logOverride,
    legalComments: options.legalComments
  };
  if (options.minifyIdentifiers != null || options.minifySyntax != null || options.minifyWhitespace != null) {
    return {
      ...base,
      minifyIdentifiers: options.minifyIdentifiers ?? true,
      minifySyntax: options.minifySyntax ?? true,
      minifyWhitespace: options.minifyWhitespace ?? true
    };
  }
  return { ...base, minify: true };
}

function setupPublicAssetStrategy(options = {}) {
  const assetsBaseURL = options.prefix || "/_fonts";
  const nuxt = useNuxt();
  const renderedFontURLs = /* @__PURE__ */ new Map();
  function normalizeFontData(faces) {
    const data = [];
    for (const face of Array.isArray(faces) ? faces : [faces]) {
      data.push({
        ...face,
        unicodeRange: face.unicodeRange === void 0 || Array.isArray(face.unicodeRange) ? face.unicodeRange : [face.unicodeRange],
        src: (Array.isArray(face.src) ? face.src : [face.src]).map((src) => {
          const source = typeof src === "string" ? parseFont(src) : src;
          if ("url" in source && hasProtocol(source.url, { acceptRelative: true })) {
            source.url = source.url.replace(/^\/\//, "https://");
            const file = [
              filename(source.url.replace(/\?.*/, "")),
              hash(source) + (extname(source.url) || formatToExtension(source.format) || "")
            ].filter(Boolean).join("-");
            renderedFontURLs.set(file, source.url);
            source.originalURL = source.url;
            source.url = nuxt.options.dev ? joinRelativeURL(nuxt.options.app.baseURL, assetsBaseURL, file) : joinURL(assetsBaseURL, file);
          }
          return source;
        })
      });
    }
    return data;
  }
  addDevServerHandler({
    route: assetsBaseURL,
    handler: lazyEventHandler(async () => {
      return eventHandler(async (event) => {
        const filename2 = event.path.slice(1);
        const url = renderedFontURLs.get(event.path.slice(1));
        if (!url) {
          throw createError({ statusCode: 404 });
        }
        const key = "data:fonts:" + filename2;
        let res = await storage.getItemRaw(key);
        if (!res) {
          res = await fetch(url).then((r) => r.arrayBuffer()).then((r) => Buffer.from(r));
          await storage.setItemRaw(key, res);
        }
        return res;
      });
    })
  });
  if (nuxt.options.dev) {
    nuxt.options.routeRules ||= {};
    nuxt.options.routeRules[joinURL(assetsBaseURL, "**")] = {
      cache: {
        maxAge: ONE_YEAR_IN_SECONDS
      }
    };
  }
  nuxt.options.nitro.publicAssets ||= [];
  const cacheDir = join(nuxt.options.buildDir, "cache", "fonts");
  nuxt.options.nitro = defu$1(nuxt.options.nitro, {
    publicAssets: [{
      dir: cacheDir,
      maxAge: ONE_YEAR_IN_SECONDS,
      baseURL: assetsBaseURL
    }],
    ignore: [`!${join(cacheDir, "**/*")}`],
    prerender: {
      ignore: [assetsBaseURL]
    }
  });
  nuxt.hook("nitro:init", async (nitro) => {
    if (nuxt.options.dev) {
      return;
    }
    nitro.hooks.hook("rollup:before", async () => {
      await fsp.rm(cacheDir, { recursive: true, force: true });
      await fsp.mkdir(cacheDir, { recursive: true });
      let banner = false;
      for (const [filename2, url] of renderedFontURLs) {
        const key = "data:fonts:" + filename2;
        let res = await storage.getItemRaw(key);
        if (!res) {
          if (!banner) {
            banner = true;
            logger.info("Downloading fonts...");
          }
          logger.log(chalk.gray("  \u251C\u2500 " + url));
          res = await fetch(url).then((r) => r.arrayBuffer()).then((r) => Buffer.from(r));
          await storage.setItemRaw(key, res);
        }
        await fsp.writeFile(join(cacheDir, filename2), res);
      }
      if (banner) {
        logger.success("Fonts downloaded and cached.");
      }
    });
  });
  return { normalizeFontData };
}
const ONE_YEAR_IN_SECONDS = 60 * 60 * 24 * 365;

const DEVTOOLS_UI_PATH = "/__nuxt-devtools-fonts";
const DEVTOOLS_UI_PORT = 3300;
const DEVTOOLS_RPC_NAMESPACE = "nuxt-devtools-fonts";

function setupDevToolsUI() {
  const nuxt = useNuxt();
  const resolver = createResolver(import.meta.url);
  const clientPath = resolver.resolve("./client");
  const isProductionBuild = existsSync(clientPath);
  if (isProductionBuild) {
    nuxt.hook("vite:serverCreated", async (server) => {
      const sirv = await import('sirv').then((r) => r.default || r);
      server.middlewares.use(
        DEVTOOLS_UI_PATH,
        sirv(clientPath, { dev: true, single: true })
      );
    });
  } else {
    nuxt.hook("vite:extendConfig", (config) => {
      config.server = config.server || {};
      config.server.proxy = config.server.proxy || {};
      config.server.proxy[DEVTOOLS_UI_PATH] = {
        target: `http://localhost:${DEVTOOLS_UI_PORT}${DEVTOOLS_UI_PATH}`,
        changeOrigin: true,
        followRedirects: true,
        rewrite: (path) => path.replace(DEVTOOLS_UI_PATH, "")
      };
    });
  }
  addCustomTab({
    name: "fonts",
    title: "Fonts",
    icon: "carbon:text-font",
    view: {
      type: "iframe",
      src: DEVTOOLS_UI_PATH
    }
  });
}
function setupDevtoolsConnection(enabled) {
  if (!enabled) {
    return { exposeFont: () => {
    } };
  }
  setupDevToolsUI();
  let rpc;
  const fonts = [];
  onDevToolsInitialized(() => {
    rpc = extendServerRpc(DEVTOOLS_RPC_NAMESPACE, {
      getFonts: () => fonts,
      generateFontFace
    });
    rpc.broadcast.exposeFonts.asEvent(fonts);
  });
  function exposeFonts(font) {
    rpc?.broadcast.exposeFonts.asEvent([font]);
    fonts.push(font);
  }
  return {
    exposeFont: exposeFonts
  };
}

const defaultValues = {
  weights: [400],
  styles: ["normal", "italic"],
  subsets: [
    "cyrillic-ext",
    "cyrillic",
    "greek-ext",
    "greek",
    "vietnamese",
    "latin-ext",
    "latin"
  ],
  fallbacks: {
    "serif": ["Times New Roman"],
    "sans-serif": ["Arial"],
    "monospace": ["Courier New"],
    "cursive": [],
    "fantasy": [],
    "system-ui": [
      "BlinkMacSystemFont",
      "Segoe UI",
      "Roboto",
      "Helvetica Neue",
      "Arial"
    ],
    "ui-serif": ["Times New Roman"],
    "ui-sans-serif": ["Arial"],
    "ui-monospace": ["Courier New"],
    "ui-rounded": [],
    "emoji": [],
    "math": [],
    "fangsong": []
  }
};
const module = defineNuxtModule({
  meta: {
    name: "@nuxt/fonts",
    configKey: "fonts"
  },
  defaults: {
    devtools: true,
    experimental: {
      processCSSVariables: false
    },
    defaults: {},
    assets: {
      prefix: "/_fonts"
    },
    local: {},
    google: {},
    adobe: {
      id: ""
    },
    providers: {
      local,
      adobe,
      google,
      bunny,
      fontshare,
      fontsource
    }
  },
  async setup(options, nuxt) {
    if (nuxt.options._prepare)
      return;
    const normalizedDefaults = {
      weights: (options.defaults?.weights || defaultValues.weights).map((v) => String(v)),
      styles: options.defaults?.styles || defaultValues.styles,
      subsets: options.defaults?.subsets || defaultValues.subsets,
      fallbacks: Object.fromEntries(Object.entries(defaultValues.fallbacks).map(([key, value]) => [
        key,
        Array.isArray(options.defaults?.fallbacks) ? options.defaults.fallbacks : options.defaults?.fallbacks?.[key] || value
      ]))
    };
    if (!options.defaults?.fallbacks || !Array.isArray(options.defaults.fallbacks)) {
      const fallbacks = options.defaults.fallbacks ||= {};
      for (const _key in defaultValues.fallbacks) {
        const key = _key;
        fallbacks[key] ||= defaultValues.fallbacks[key];
      }
    }
    const providers = await resolveProviders(options.providers);
    const prioritisedProviders = /* @__PURE__ */ new Set();
    nuxt.hook("modules:done", async () => {
      await nuxt.callHook("fonts:providers", providers);
      const setups = [];
      for (const key in providers) {
        const provider = providers[key];
        if (options.providers?.[key] === false || options.provider && options.provider !== key) {
          delete providers[key];
        } else if (provider.setup) {
          setups.push(provider.setup(options[key] || {}, nuxt));
        }
      }
      await Promise.all(setups);
      for (const val of options.priority || []) {
        if (val in providers)
          prioritisedProviders.add(val);
      }
      for (const provider in providers) {
        prioritisedProviders.add(provider);
      }
    });
    const { normalizeFontData } = setupPublicAssetStrategy(options.assets);
    const { exposeFont } = setupDevtoolsConnection(nuxt.options.dev && !!options.devtools);
    async function resolveFontFaceWithOverride(fontFamily, override, fallbackOptions) {
      const fallbacks = override?.fallbacks || normalizedDefaults.fallbacks[fallbackOptions?.generic || "sans-serif"];
      if (override && "src" in override) {
        const fonts = normalizeFontData({
          src: override.src,
          display: override.display,
          weight: override.weight,
          style: override.style
        });
        exposeFont({
          type: "manual",
          fontFamily,
          fonts
        });
        return {
          fallbacks,
          fonts
        };
      }
      if (override?.provider === "none") {
        return;
      }
      const defaults = { ...normalizedDefaults, fallbacks };
      for (const key of ["weights", "styles", "subsets"]) {
        if (override?.[key]) {
          defaults[key] = override[key].map((v) => String(v));
        }
      }
      if (override?.provider) {
        if (override.provider in providers) {
          const result = await providers[override.provider].resolveFontFaces(fontFamily, defaults);
          const fonts = normalizeFontData(result?.fonts || []);
          if (!fonts.length || !result) {
            logger.warn(`Could not produce font face declaration from \`${override.provider}\` for font family \`${fontFamily}\`.`);
            return;
          }
          exposeFont({
            type: "override",
            fontFamily,
            provider: override.provider,
            fonts
          });
          return {
            fallbacks: result.fallbacks || defaults.fallbacks,
            fonts
          };
        }
        logger.warn(`Unknown provider \`${override.provider}\` for font family \`${fontFamily}\`. Falling back to default providers.`);
      }
      for (const key of prioritisedProviders) {
        const provider = providers[key];
        if (provider.resolveFontFaces) {
          const result = await provider.resolveFontFaces(fontFamily, defaults);
          if (result) {
            const fonts = normalizeFontData(result.fonts);
            if (fonts.length > 0) {
              exposeFont({
                type: "auto",
                fontFamily,
                provider: key,
                fonts
              });
              return {
                fallbacks: result.fallbacks || defaults.fallbacks,
                fonts
              };
            }
            if (override) {
              logger.warn(`Could not produce font face declaration for \`${fontFamily}\` with override.`);
            }
          }
        }
      }
    }
    nuxt.options.css.push("#build/nuxt-fonts-global.css");
    addTemplate({
      filename: "nuxt-fonts-global.css",
      write: true,
      // Seemingly necessary to allow vite to process file ðŸ¤”
      async getContents() {
        let css = "";
        for (const family of options.families || []) {
          if (!family.global)
            continue;
          const result = await resolveFontFaceWithOverride(family.name, family);
          for (const font of result?.fonts || []) {
            css += generateFontFace(family.name, font) + "\n";
          }
        }
        return css;
      }
    });
    const fontMap = /* @__PURE__ */ new Map();
    nuxt.hook("build:manifest", (manifest) => {
      function addPreloadLinks(chunk, urls) {
        chunk.assets ||= [];
        for (const url of urls) {
          chunk.assets.push(url);
          if (!manifest[url]) {
            manifest[url] = {
              file: relative(nuxt.options.app.buildAssetsDir, url),
              resourceType: "font",
              preload: true
            };
          }
        }
      }
      for (const id in manifest) {
        const chunk = manifest[id];
        if (!chunk.css || chunk.css.length === 0)
          continue;
        for (const css of chunk.css) {
          const assetName = withoutLeadingSlash(join(nuxt.options.app.buildAssetsDir, css));
          if (fontMap.has(assetName)) {
            addPreloadLinks(chunk, fontMap.get(assetName));
          }
        }
      }
      for (const [id, urls] of fontMap) {
        const chunk = manifest[relative(nuxt.options.srcDir, id)];
        if (!chunk)
          continue;
        addPreloadLinks(chunk, urls);
      }
    });
    addBuildPlugin(FontFamilyInjectionPlugin({
      dev: nuxt.options.dev,
      fontsToPreload: fontMap,
      processCSSVariables: options.experimental?.processCSSVariables,
      shouldPreload(fontFamily, fontFace) {
        const override = options.families?.find((f) => f.name === fontFamily);
        if (override && override.preload !== void 0) {
          return override.preload;
        }
        if (options.defaults?.preload !== void 0) {
          return options.defaults.preload;
        }
        return fontFace.src.some((s) => "url" in s) && !fontFace.unicodeRange;
      },
      async resolveFontFace(fontFamily, fallbackOptions) {
        const override = options.families?.find((f) => f.name === fontFamily);
        if (override?.global) {
          return;
        }
        return resolveFontFaceWithOverride(fontFamily, override, fallbackOptions);
      }
    }));
  }
});
async function resolveProviders(_providers = {}) {
  const nuxt = useNuxt();
  const _jiti = jiti(nuxt.options.rootDir, { interopDefault: true });
  const providers = { ..._providers };
  for (const key in providers) {
    const value = providers[key];
    if (value === false) {
      delete providers[key];
    }
    if (typeof value === "string") {
      providers[key] = await _jiti(await resolvePath(resolveAlias(value)));
    }
  }
  return providers;
}

export { module as default };
