{"version":3,"file":"text.js","sources":["../../src/utils/text.ts"],"sourcesContent":["import { Selection } from 'd3-selection'\nimport { sum } from 'd3-array'\nimport striptags from 'striptags'\n\n// Types\nimport { TextAlign, TrimMode, UnovisText, UnovisTextFrameOptions, UnovisTextOptions, UnovisWrappedText, VerticalAlign } from 'types/text'\n\n// Utils\nimport { flatten, isArray, merge } from 'utils/data'\nimport { getTextAnchorFromTextAlign } from 'types/svg'\n\n// Styles\nimport { getFontWidthToHeightRatio, UNOVIS_TEXT_DEFAULT, UNOVIS_TEXT_SEPARATOR_DEFAULT, UNOVIS_TEXT_HYPHEN_CHARACTER_DEFAULT } from 'styles/index'\n\n/**\n * Converts a kebab-case string to camelCase.\n *\n * @param {string} str - The kebab-case string to be converted.\n * @returns {string} The resulting camelCase string.\n */\nexport function kebabCaseToCamel (str: string): string {\n  return str.replace(/-([a-z])/g, (_, letter) => letter.toUpperCase())\n}\n\n/**\n * Converts a given string to kebab-case.\n * @param {string} str - The input string to be converted to kebab-case.\n * @returns {string} - The kebab-cased string.\n */\nexport function kebabCase (str: string): string {\n  return str.match(/[A-Z]{2,}(?=[A-Z][a-z0-9]*|\\b)|[A-Z]?[a-z0-9]*|[A-Z]|[0-9]+/g)\n    ?.filter(Boolean)\n    .map(x => x.toLowerCase())\n    .join('-')\n}\n\nexport function escapeStringKeepHash (str: string): string {\n  return str\n    .replace(/['\"]/g, '&#39;') // Escapes quotes with &#39;\n    // eslint-disable-next-line no-control-regex\n    .replace(/\\u0000/g, '\\\\0') // Escapes null characters\n    .replace(/\\n/g, '\\\\n') // Escapes new lines\n    .replace(/\\r/g, '\\\\r') // Escapes carriage returns\n    .replace(/\\v/g, '\\\\v') // Escapes vertical tabs\n    .replace(/\\t/g, '\\\\t') // Escapes horizontal tabs\n    .replace(/\\f/g, '\\\\f') // Escapes form feeds\n}\n\n/**\n * Trims the input string from the start, leaving only the specified maximum length.\n * @param {string} [str=''] - The input string to be trimmed.\n * @param {number} [maxLength=15] - The maximum allowed length of the trimmed string.\n * @returns {string} - The trimmed string.\n */\nexport function trimStringStart (str = '', maxLength = 15): string {\n  return str.length > maxLength ? `…${str.substr(str.length - maxLength, maxLength)}` : str\n}\n\n/**\n * Trims the input string from the middle, leaving only the specified maximum length.\n * @param {string} [str=''] - The input string to be trimmed.\n * @param {number} [maxLength=15] - The maximum allowed length of the trimmed string.\n * @returns {string} - The trimmed string.\n */\nexport function trimStringMiddle (str = '', maxLength = 15): string {\n  const dist = Math.floor((maxLength - 3) / 2)\n  return str.length > maxLength ? `${str.substr(0, dist)}…${str.substr(-dist, dist)}` : str\n}\n\n/**\n * Trims the input string from the end, leaving only the specified maximum length.\n * @param {string} [str=''] - The input string to be trimmed.\n * @param {number} [maxLength=15] - The maximum allowed length of the trimmed string.\n * @returns {string} - The trimmed string.\n */\nexport function trimStringEnd (str = '', maxLength = 15): string {\n  return str.length > maxLength ? `${str.substr(0, maxLength)}…` : str\n}\n\n/**\n * Trims the input string according to the specified trim mode.\n * @param {string} [str=''] - The input string to be trimmed.\n * @param {number} [length=15] - The maximum allowed length of the trimmed string.\n * @param {TrimMode} [type=TrimMode.Middle] - The trim mode to be applied.\n * @returns {string} - The trimmed string.\n */\nexport function trimString (str = '', length = 15, type = TrimMode.Middle): string {\n  let result = trimStringEnd(str, length)\n  if (type === TrimMode.Start) result = trimStringStart(str, length)\n  else if (type === TrimMode.Middle) result = trimStringMiddle(str, length)\n  return result\n}\n\n/**\n * Splits the input string according to the specified separators.\n * @param {string} text - The input string to be split.\n * @param {string[]} [separators=[' ']] - The array of separators to be used for splitting.\n * @returns {string[]} - The array of split words.\n */\nexport function splitString (text: string, separators = [' ']): string[] {\n  let result = [text] as Array<string | string[]>\n  for (let i = 0; i < separators.length; i++) {\n    const sep = separators[i]\n    result.forEach((d, index) => {\n      const separated = (d as string).split(sep)\n      const words = separated.map((word, j) => `${word}${j === separated.length - 1 ? '' : sep}`)\n      result[index] = words\n    })\n    result = flatten(result)\n  }\n\n  return result as string[]\n}\n\n/**\n * Wraps an SVG text element to fit within the specified width.\n * @param {Selection<SVGTextElement, any, SVGElement, any>} textElement - The SVG text element to be wrapped.\n * @param {number} width - The maximum allowed width for the text element.\n * @param {(string | string[])} [separator=[' ', '-', '.', ',']] - The separator(s) to be used for wrapping.\n */\nexport function wrapSVGText (\n  textElement: Selection<SVGTextElement, any, SVGElement, any>,\n  width: number,\n  separator: string | string[] = [' ', '-', '.', ',']\n): void {\n  const text = textElement.text()\n  if (!text) return\n\n  // Wrap\n  const separators = (isArray(separator) ? separator : [separator]) as string[]\n  const words = splitString(text, separators)\n  const x = parseFloat(textElement.attr('x')) || 0\n\n  textElement.text('')\n  let tspan = textElement.append('tspan').attr('x', x)\n  let tspanContent = `${words[0]}`\n  tspan.text(tspanContent)\n\n  words.forEach((word, i) => {\n    if (i === 0) return\n\n    const tspanText = `${tspanContent}${word}`\n    tspan.text(tspanText)\n    const tspanWidth = tspan.node().getComputedTextLength()\n    if (tspanWidth > width) {\n      tspan.text(tspanContent.trim())\n\n      tspan = textElement.append('tspan')\n        .attr('x', x)\n        .attr('dy', '1.2em')\n        .text(word)\n\n      tspanContent = word\n    } else tspanContent += word\n  })\n}\n\n/**\n * Trims an SVG text element based on the specified max width, trim type, and other options.\n * @param {Selection<SVGTextElement, any, SVGElement, any>} svgTextSelection - The D3 selection of the SVG text element to be trimmed.\n * @param {number} [maxWidth=50] - The maximum width of the text element.\n * @param {TrimMode} [trimType=TrimMode.Middle] - The type of trim (start, middle, or end).\n * @param {boolean} [fastMode=true] - Whether to use a fast estimation method for text length calculation.\n * @param {number} [fontSize=0] - The font size of the text.\n * @param {number} [fontWidthToHeightRatio=getFontWidthToHeightRatio()] - The font width to height ratio.\n * @returns {boolean} True if the text was trimmed, false otherwise.\n */\nexport function trimSVGText (\n  svgTextSelection: Selection<SVGTextElement, any, SVGElement, any>,\n  maxWidth = 50,\n  trimType = TrimMode.Middle,\n  fastMode = true,\n  fontSize = +window.getComputedStyle(svgTextSelection.node())?.fontSize || 0,\n  fontWidthToHeightRatio = getFontWidthToHeightRatio()\n): boolean {\n  const text = svgTextSelection.text()\n  const textLength = text.length\n\n  const textWidth = fastMode ? fontSize * textLength * fontWidthToHeightRatio : svgTextSelection.node().getComputedTextLength()\n  const tolerance = 1.1\n  const maxCharacters = Math.ceil(textLength * maxWidth / (tolerance * textWidth))\n  if (maxCharacters < textLength) {\n    svgTextSelection.text(trimString(text, maxCharacters, trimType))\n    return true\n  }\n\n  return false\n}\n\n/**\n * Estimates the length of a string in pixels.\n * @param {string} str - The string to be measured.\n * @param {number} fontSize - The font size of the string.\n * @param {number} [fontWidthToHeightRatio=getFontWidthToHeightRatio()] - The font width to height ratio.\n * @returns {number} The estimated length of the string in pixels.\n */\nexport function estimateStringPixelLength (\n  str: string,\n  fontSize: number,\n  fontWidthToHeightRatio = getFontWidthToHeightRatio()\n): number {\n  return str.length * fontSize * fontWidthToHeightRatio || 0\n}\n\n/**\n * Calculates the precise length of a string in pixels.\n * @param {string} str - The string to be measured.\n * @param {string} [fontFamily] - The font family of the string.\n * @param {(string | number)} [fontSize] - The font size of the string.\n * @returns {number} The precise length of the string in pixels.\n */\nexport function getPreciseStringLengthPx (str: string, fontFamily?: string, fontSize?: string | number): number {\n  const svgNS = 'http://www.w3.org/2000/svg'\n  const svg = document.createElementNS(svgNS, 'svg')\n  const text = document.createElementNS(svgNS, 'text')\n\n  text.textContent = str\n  text.setAttribute('font-size', `${fontSize}`)\n  text.setAttribute('font-family', fontFamily)\n\n  svg.appendChild(text)\n  document.body.appendChild(svg)\n  const length = text.getComputedTextLength()\n  document.body.removeChild(svg)\n\n  return length\n}\n\n/**\n * Estimates the dimensions of an SVG text element.\n *\n * @export\n * @param {Selection<SVGTextElement, any, SVGElement, any>} svgTextSelection - The D3 selection of the SVG text element.\n * @param {number} fontSize - The font size.\n * @param {number} [dy=0.32] - The line height scaling factor.\n * @param {boolean} [fastMode=true] - Whether to use a fast estimation method or a more accurate one.\n * @param {number} [fontWidthToHeightRatio] - The font width-to-height ratio.\n * @returns {{width: number, height: number}} - The estimated dimensions of the text element.\n */\nexport function estimateTextSize (\n  svgTextSelection: Selection<SVGTextElement, any, SVGElement, any>,\n  fontSize: number,\n  dy = 0.32,\n  fastMode = true,\n  fontWidthToHeightRatio?: number\n): { width: number; height: number } {\n  fontWidthToHeightRatio = fontWidthToHeightRatio || getFontWidthToHeightRatio()\n  const tspanSelection = svgTextSelection.selectAll('tspan')\n\n  const lines = tspanSelection.size() || 1\n  const height = svgTextSelection.text() ? 0.85 * fontSize * lines * (1 + dy) - dy : 0\n\n  let width = 0\n  if (tspanSelection.empty()) {\n    const textLength = svgTextSelection.text().length\n    width = fastMode ? fontSize * textLength * fontWidthToHeightRatio : svgTextSelection.node().getComputedTextLength()\n  } else {\n    for (const tspan of tspanSelection.nodes()) {\n      const tspanTextLength = (tspan as SVGTSpanElement).textContent.length\n      const w = fastMode ? fontSize * tspanTextLength * fontWidthToHeightRatio : (tspan as SVGTSpanElement).getComputedTextLength()\n      if (w > width) width = w\n    }\n  }\n\n  return { width, height }\n}\n\n/**\n * Breaks a text block into lines based on the specified width.\n *\n * @param {UnovisText} textBlock - The text block to break into lines.\n * @param {number | undefined} [width=undefined] - The maximum width of a line in pixels.\n * @param {(number | undefined)} [height=undefined] - The height limit for the wrapped text in pixels.\n * @param {boolean} [fastMode=true] - Whether to use a fast estimation method or a more accurate one.\n * @param {string | string[]} [separator] - The word separators.\n * @returns {string[]} - The text split into lines.\n */\nfunction breakTextIntoLines (\n  textBlock: UnovisText,\n  width: number | undefined = undefined,\n  fastMode = true,\n  separator: string | string[] = UNOVIS_TEXT_SEPARATOR_DEFAULT,\n  wordBreak = false\n): string[] {\n  const text = `${textBlock.text}`\n  if (!text) return []\n  const separators = Array.isArray(separator) ? separator : [separator]\n\n  const splitByNewLine = text.split('\\n')\n  return splitByNewLine.map((str) => {\n    const lines: string[] = []\n    if (!width) return [str]\n\n    const words = splitString(str, separators)\n    let line = ''\n    for (let i = 0; i < words.length; i += 1) {\n      const textLengthPx = fastMode\n        ? estimateStringPixelLength(line + words[i], textBlock.fontSize, textBlock.fontWidthToHeightRatio)\n        : getPreciseStringLengthPx(line + words[i], textBlock.fontFamily, textBlock.fontSize)\n\n      if (textLengthPx < width || i === 0) {\n        line += words[i]\n      } else {\n        lines.push(line.trim())\n        line = words[i]\n      }\n\n      // Word break functionality\n      const minCharactersOnLine = 2\n      if (wordBreak) {\n        while (line.trim().length > minCharactersOnLine) {\n          const subLineLengthPx = fastMode\n            ? estimateStringPixelLength(line, textBlock.fontSize, textBlock.fontWidthToHeightRatio)\n            : getPreciseStringLengthPx(line, textBlock.fontFamily, textBlock.fontSize)\n\n          if (subLineLengthPx > width) {\n            let breakIndex = (line.trim()).length - minCharactersOnLine // Place at least `minCharactersOnLine` characters onto the next line\n            while (breakIndex > 0) {\n              const subLine = `${line.substring(0, breakIndex)}${UNOVIS_TEXT_HYPHEN_CHARACTER_DEFAULT}` // Use hyphen when force breaking words\n              const subLinePx = fastMode\n                ? estimateStringPixelLength(subLine, textBlock.fontSize, textBlock.fontWidthToHeightRatio)\n                : getPreciseStringLengthPx(subLine, textBlock.fontFamily, textBlock.fontSize)\n\n              // If the subline is less than the width, or just one character left, break the line\n              if (subLinePx <= width || breakIndex === 1) {\n                lines.push(subLine.trim())\n                line = line.substring(breakIndex)\n                break\n              }\n              breakIndex--\n            }\n          } else {\n            break\n          }\n        }\n      }\n    }\n\n    // Adding the final line after the loop\n    if (line) lines.push(line.trim())\n\n    return lines\n  }).flat()\n}\n\n/**\n * Wraps a text or array of texts to fit within specified width and height, if provided.\n *\n * @export\n * @param {UnovisText | UnovisText[]} text - The text or array of texts to wrap.\n * @param {number | undefined} [width=undefined] - The maximum width of a line in pixels.\n * @param {boolean} [fastMode=true] - Whether to use a fast estimation method or a more accurate one.\n * @param {string | string[]} [separator] - The word separators.\n * @returns {UnovisWrappedText[]} - The wrapped texts.\n */\nexport function getWrappedText (\n  text: UnovisText | UnovisText[],\n  width: number | undefined = undefined,\n  height: number | undefined = undefined,\n  fastMode = true,\n  separator: string | string[] = UNOVIS_TEXT_SEPARATOR_DEFAULT,\n  wordBreak = false\n): UnovisWrappedText[] {\n  // Merge input text with default values and convert it to an array if it's not already\n  const textArrays = Array.isArray(text) ? text.map(t => merge(UNOVIS_TEXT_DEFAULT, t)) : [merge(UNOVIS_TEXT_DEFAULT, text)]\n\n  // Break input text into lines based on width and separator\n  const textWrapped: Array<string[]> = textArrays.map(block => breakTextIntoLines(block, width, fastMode, separator, wordBreak))\n\n  const firstBlock = textArrays[0]\n  let h = -firstBlock.fontSize * (firstBlock.lineHeight - 1)\n  const blocks: UnovisWrappedText[] = []\n\n  // Process each text block and its lines based on height limit\n  textArrays.forEach((text, i) => {\n    let lines = textWrapped[i]\n\n    const prevBlock = i > 0 ? blocks[i - 1] : undefined\n    const prevBlockMarginBottomPx = prevBlock ? prevBlock.marginBottom : 0\n    const marginTopPx = text.marginTop\n    const effectiveMarginPx = Math.max(prevBlockMarginBottomPx, marginTopPx)\n\n    h += effectiveMarginPx\n    const dh = text.fontSize * text.lineHeight\n    // Iterate over lines and handle text overflow based on the height limit if provided\n    for (let k = 0; k < lines.length; k += 1) {\n      let line = lines[k]\n      h += dh\n\n      if (height && (h + dh) > height && (k !== lines.length - 1)) {\n        // Remove hyphen character from the end of the line if it's there\n        const lastCharacter = line.charAt(line.length - 1)\n        if (lastCharacter === UNOVIS_TEXT_HYPHEN_CHARACTER_DEFAULT) {\n          line = line.substr(0, lines[k].length - 1)\n        }\n\n        const lineWithEllipsis = `${line} …`\n        const textLengthPx = fastMode\n          ? estimateStringPixelLength(lineWithEllipsis, text.fontSize, text.fontWidthToHeightRatio)\n          : getPreciseStringLengthPx(lineWithEllipsis, text.fontFamily, text.fontSize)\n\n        if (textLengthPx < width) {\n          lines[k] = lineWithEllipsis\n        } else {\n          lines[k] = `${lines[k].substr(0, lines[k].length - 2)}…`\n        }\n\n        lines = lines.slice(0, k + 1)\n        break\n      }\n    }\n\n    // Create wrapped text block with its calculated properties\n    blocks.push({ ...text, _lines: lines, _estimatedHeight: h - (prevBlock?._estimatedHeight || 0) })\n  })\n\n  return blocks\n}\n\n\n/**\n * Renders a text or array of texts to SVG tspan strings.\n *\n * @param {UnovisWrappedText[]} blocks - The wrapped text blocks.\n * @param {number} [x=0] - The x-coordinate for the tspan elements.\n * @param {number} [y] - The y-coordinate for the tspan elements.\n * @returns {string[]} - The SVG tspan strings.\n */\nfunction renderTextToTspanStrings (blocks: UnovisWrappedText[], x = 0, y?: number): string[] {\n  return blocks.map((b, i) => {\n    const prevBlock = i > 0 ? blocks[i - 1] : undefined\n    const prevBlockMarginBottomEm = prevBlock ? prevBlock.marginBottom / prevBlock.fontSize : 0\n    const marginTopEm = b.marginTop / b.fontSize\n    const marginEm = Math.max(prevBlockMarginBottomEm, marginTopEm)\n    const attributes = {\n      fontSize: b.fontSize,\n      fontFamily: b.fontFamily,\n      fontWeight: b.fontWeight,\n      fill: b.color,\n      y: (i === 0) && y,\n    }\n\n    const attributesString = Object.entries(attributes)\n      .filter(([_, value]) => value)\n      .map(([key, value]) => `${kebabCase(key)}=\"${escapeStringKeepHash(value.toString())}\"`)\n      .join(' ')\n\n    return `<tspan xmlns=\"http://www.w3.org/2000/svg\" ${attributesString}>${b._lines.map((line, k) => {\n      let dy: number\n      if (i === 0 && k === 0) dy = 0.8 + marginEm\n      else if (k === 0) dy = marginEm + b.lineHeight\n      else dy = b.lineHeight\n\n      return `<tspan x=\"${x}\" dy=\"${dy}em\">${line.length ? line : ' '}</tspan>`\n    }).join('')}</tspan>`\n  })\n}\n\n/**\n * Estimates the height of wrapped text blocks.\n *\n * @export\n * @param {UnovisWrappedText[]} blocks - The wrapped text blocks.\n * @returns {number} - The estimated height of the wrapped text blocks.\n */\nexport function estimateWrappedTextHeight (blocks: UnovisWrappedText[]): number {\n  return sum(blocks, b => b._estimatedHeight)\n}\n\nexport const allowedSvgTextTags = ['text', 'tspan', 'textPath', 'altGlyph', 'altGlyphDef', 'altGlyphItem', 'glyphRef', 'textRef', 'textArea']\n\n/**\n * Renders a text or array of texts to an SVG text element.\n * Calling this function will replace the contents of the specified SVG text element.\n *\n * @export\n * @param {SVGTextElement} textElement - The SVG text element to render the text into.\n * @param {UnovisText | UnovisText[]} text - The text or array of texts to render.\n * @param {UnovisTextOptions} options - The text options.\n */\nexport function renderTextToSvgTextElement (\n  textElement: SVGTextElement,\n  text: UnovisText | UnovisText[],\n  options: UnovisTextOptions\n): void {\n  const wrappedText = getWrappedText(text, options.width, undefined, options.fastMode, options.separator, options.wordBreak)\n  const textElementX = options.x ?? +textElement.getAttribute('x')\n  const textElementY = options.y ?? +textElement.getAttribute('y')\n  const x = textElementX ?? 0\n  let y = textElementY ?? 0\n  if (options.textAlign) textElement.setAttribute('text-anchor', getTextAnchorFromTextAlign(options.textAlign))\n  if (options.verticalAlign && options.verticalAlign !== VerticalAlign.Top) {\n    const height = estimateWrappedTextHeight(wrappedText)\n    const dy = options.verticalAlign === VerticalAlign.Middle ? -height / 2\n      : options.verticalAlign === VerticalAlign.Bottom ? -height : 0\n\n    y += dy\n  }\n\n  const parser = new DOMParser()\n  textElement.textContent = ''\n  wrappedText.forEach(block => {\n    const svgCode = renderTextToTspanStrings([block], x, y).join('')\n    const svgCodeSanitized = striptags(svgCode, allowedSvgTextTags)\n    const parsedSvgCode = parser.parseFromString(svgCodeSanitized, 'image/svg+xml').firstChild\n    textElement.appendChild(parsedSvgCode)\n  })\n}\n\n/**\n * Renders a text or array of texts into a frame.\n * Calling this function will replace the contents of the specified SVG group.\n *\n * @export\n * @param {SVGGElement} group - The SVG group element to render the text into.\n * @param {UnovisText | UnovisText[]} text - The text or array of texts to render.\n * @param {UnovisTextFrameOptions} frameOptions - The text frame options.\n */\nexport function renderTextIntoFrame (\n  group: SVGGElement,\n  text: UnovisText | UnovisText[],\n  frameOptions: UnovisTextFrameOptions\n): void {\n  const wrappedText = getWrappedText(text, frameOptions.width, frameOptions.height, frameOptions.fastMode, frameOptions.separator, frameOptions.wordBreak)\n\n  const x = frameOptions.textAlign === TextAlign.Center ? frameOptions.width / 2\n    : frameOptions.textAlign === TextAlign.Right ? frameOptions.width : 0\n\n  let y = 0\n  const height = estimateWrappedTextHeight(wrappedText)\n\n  // If the frame has height, the text will be vertically aligned within the frame.\n  // If not, the text will be aligned against the `y` position of the frame.\n  const dh = frameOptions.height - height\n  y = frameOptions.verticalAlign === VerticalAlign.Middle ? dh / 2\n    : frameOptions.verticalAlign === VerticalAlign.Bottom ? dh : 0\n\n\n  const translate = (frameOptions.x || frameOptions.y)\n    ? `transform=\"translate(${frameOptions.x ?? 0},${frameOptions.y ?? 0})\"`\n    : ''\n\n  const svgCode =\n  `<text\n    xmlns=\"http://www.w3.org/2000/svg\"\n    text-anchor=\"${getTextAnchorFromTextAlign(frameOptions.textAlign)}\"\n    ${translate}\n  >\n    ${renderTextToTspanStrings(wrappedText, x, y).join('')}\n  </text>`\n\n  const parser = new DOMParser()\n  const svgCodeSanitized = striptags(svgCode, allowedSvgTextTags)\n  const parsedSvgCode = parser.parseFromString(svgCodeSanitized, 'image/svg+xml').firstChild\n\n  group.textContent = ''\n  group.appendChild(parsedSvgCode)\n}\n"],"names":[],"mappings":"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"}