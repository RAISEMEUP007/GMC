{"version":3,"sources":["../../../../src/interceptors/fetch/index.ts","../../../../src/utils/canParseUrl.ts"],"sourcesContent":["import { invariant } from 'outvariant'\nimport { DeferredPromise } from '@open-draft/deferred-promise'\nimport { until } from '@open-draft/until'\nimport { HttpRequestEventMap, IS_PATCHED_MODULE } from '../../glossary'\nimport { Interceptor } from '../../Interceptor'\nimport { toInteractiveRequest } from '../../utils/toInteractiveRequest'\nimport { emitAsync } from '../../utils/emitAsync'\nimport { isPropertyAccessible } from '../../utils/isPropertyAccessible'\nimport { canParseUrl } from '../../utils/canParseUrl'\nimport { createRequestId } from '../../createRequestId'\n\nexport class FetchInterceptor extends Interceptor<HttpRequestEventMap> {\n  static symbol = Symbol('fetch')\n\n  constructor() {\n    super(FetchInterceptor.symbol)\n  }\n\n  protected checkEnvironment() {\n    return (\n      typeof globalThis !== 'undefined' &&\n      typeof globalThis.fetch !== 'undefined'\n    )\n  }\n\n  protected async setup() {\n    const pureFetch = globalThis.fetch\n\n    invariant(\n      !(pureFetch as any)[IS_PATCHED_MODULE],\n      'Failed to patch the \"fetch\" module: already patched.'\n    )\n\n    globalThis.fetch = async (input, init) => {\n      const requestId = createRequestId()\n\n      /**\n       * @note Resolve potentially relative request URL\n       * against the present `location`. This is mainly\n       * for native `fetch` in JSDOM.\n       * @see https://github.com/mswjs/msw/issues/1625\n       */\n      const resolvedInput =\n        typeof input === 'string' &&\n        typeof location !== 'undefined' &&\n        !canParseUrl(input)\n          ? new URL(input, location.origin)\n          : input\n\n      const request = new Request(resolvedInput, init)\n\n      this.logger.info('[%s] %s', request.method, request.url)\n\n      const { interactiveRequest, requestController } =\n        toInteractiveRequest(request)\n\n      this.logger.info(\n        'emitting the \"request\" event for %d listener(s)...',\n        this.emitter.listenerCount('request')\n      )\n\n      this.emitter.once('request', ({ requestId: pendingRequestId }) => {\n        if (pendingRequestId !== requestId) {\n          return\n        }\n\n        if (requestController.responsePromise.state === 'pending') {\n          requestController.responsePromise.resolve(undefined)\n        }\n      })\n\n      this.logger.info('awaiting for the mocked response...')\n\n      const signal = interactiveRequest.signal\n      const requestAborted = new DeferredPromise()\n\n      // Signal isn't always defined in react-native.\n      if (signal) {\n        signal.addEventListener(\n          'abort',\n          () => {\n            requestAborted.reject(signal.reason)\n          },\n          { once: true }\n        )\n      }\n\n      const resolverResult = await until(async () => {\n        const listenersFinished = emitAsync(this.emitter, 'request', {\n          request: interactiveRequest,\n          requestId,\n        })\n\n        await Promise.race([\n          requestAborted,\n          // Put the listeners invocation Promise in the same race condition\n          // with the request abort Promise because otherwise awaiting the listeners\n          // would always yield some response (or undefined).\n          listenersFinished,\n          requestController.responsePromise,\n        ])\n\n        this.logger.info('all request listeners have been resolved!')\n\n        const mockedResponse = await requestController.responsePromise\n        this.logger.info('event.respondWith called with:', mockedResponse)\n\n        return mockedResponse\n      })\n\n      if (requestAborted.state === 'rejected') {\n        return Promise.reject(requestAborted.rejectionReason)\n      }\n\n      if (resolverResult.error) {\n        return Promise.reject(createNetworkError(resolverResult.error))\n      }\n\n      const mockedResponse = resolverResult.data\n\n      if (mockedResponse && !request.signal?.aborted) {\n        this.logger.info('received mocked response:', mockedResponse)\n\n        // Reject the request Promise on mocked \"Response.error\" responses.\n        if (\n          isPropertyAccessible(mockedResponse, 'type') &&\n          mockedResponse.type === 'error'\n        ) {\n          this.logger.info(\n            'received a network error response, rejecting the request promise...'\n          )\n\n          /**\n           * Set the cause of the request promise rejection to the\n           * network error Response instance. This different from Undici.\n           * Undici will forward the \"response.error\" custom property\n           * as the rejection reason but for \"Response.error()\" static method\n           * \"response.error\" will equal to undefined, making \"cause\" an empty Error.\n           * @see https://github.com/nodejs/undici/blob/83cb522ae0157a19d149d72c7d03d46e34510d0a/lib/fetch/response.js#L344\n           */\n          return Promise.reject(createNetworkError(mockedResponse))\n        }\n\n        // Clone the mocked response for the \"response\" event listener.\n        // This way, the listener can read the response and not lock its body\n        // for the actual fetch consumer.\n        const responseClone = mockedResponse.clone()\n\n        this.emitter.emit('response', {\n          response: responseClone,\n          isMockedResponse: true,\n          request: interactiveRequest,\n          requestId,\n        })\n\n        // Set the \"response.url\" property to equal the intercepted request URL.\n        Object.defineProperty(mockedResponse, 'url', {\n          writable: false,\n          enumerable: true,\n          configurable: false,\n          value: request.url,\n        })\n\n        return mockedResponse\n      }\n\n      this.logger.info('no mocked response received!')\n\n      return pureFetch(request).then((response) => {\n        const responseClone = response.clone()\n        this.logger.info('original fetch performed', responseClone)\n\n        this.emitter.emit('response', {\n          response: responseClone,\n          isMockedResponse: false,\n          request: interactiveRequest,\n          requestId,\n        })\n\n        return response\n      })\n    }\n\n    Object.defineProperty(globalThis.fetch, IS_PATCHED_MODULE, {\n      enumerable: true,\n      configurable: true,\n      value: true,\n    })\n\n    this.subscriptions.push(() => {\n      Object.defineProperty(globalThis.fetch, IS_PATCHED_MODULE, {\n        value: undefined,\n      })\n\n      globalThis.fetch = pureFetch\n\n      this.logger.info(\n        'restored native \"globalThis.fetch\"!',\n        globalThis.fetch.name\n      )\n    })\n  }\n}\n\nfunction createNetworkError(cause: unknown) {\n  return Object.assign(new TypeError('Failed to fetch'), {\n    cause,\n  })\n}\n","/**\n * Returns a boolean indicating whether the given URL string\n * can be parsed into a `URL` instance.\n * A substitute for `URL.canParse()` for Node.js 18.\n */\nexport function canParseUrl(url: string): boolean {\n  try {\n    new URL(url)\n    return true\n  } catch (_error) {\n    return false\n  }\n}\n"],"mappings":"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","names":["mockedResponse"]}